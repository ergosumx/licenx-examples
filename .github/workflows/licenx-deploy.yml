name: licenx-deploy

on:
  workflow_dispatch:
    inputs:
      dev_only:
        description: Run only the dev deployment stage
        type: boolean
        default: true
      promote_prod:
        description: Promote to prod after successful validation
        type: boolean
        default: false
      licenx_release_tag:
        description: Optional LicenX release tag (vX.Y.Z). When empty the latest published release is used.
        required: false
      container_image_tag:
        description: Optional container image tag override. Defaults to the sanitized release tag.
        required: false
      apply:
        description: Apply Terraform changes (unchecked = plan only)
        type: boolean
        default: false

permissions:
  contents: read
  id-token: write

env:
  LICENX_SUBMODULE_PATH: ergox/licenx
  LICENX_IMAGE_REPOSITORY_NAME: licenxsrv
  TERRAFORM_STATE_ACCOUNT: ergoxbuild
  TERRAFORM_STATE_CONTAINER: terraform
  TF_IN_AUTOMATION: true
  TF_VAR_subscription_id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  TF_VAR_resource_group_name: ${{ secrets.ERGOX_RG_NAME }}
  TF_VAR_location: westeurope
  TF_VAR_managed_environment_name: ergox
  TF_VAR_container_registry_name: ${{ secrets.ERGOX_ACR_NAME }}
  TF_VAR_key_vault_name: ${{ secrets.ERGOX_KV_NAME }}
  TF_VAR_cloudflare_zone_name: ergosum.in
  TF_VAR_cloudflare_zone_id: ${{ secrets.CLOUDFLARE_ERGOSUM_IN_ZONE_ID }}
  TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_USE_OIDC: true

jobs:
  prepare:
    name: Resolve Release Metadata
    runs-on: ubuntu-latest
    outputs:
      checkout_ref: ${{ steps.resolve_release.outputs.checkout_ref }}
      release_tag: ${{ steps.resolve_release.outputs.release_tag }}
      release_url: ${{ steps.resolve_release.outputs.release_url }}
      docker_tag: ${{ steps.resolve_release.outputs.docker_tag }}
    steps:
      - name: Resolve LicenX release metadata
        id: resolve_release
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}
          script: |
            const owner = 'ergosumx';
            const repo = 'licenx';
            const inputs = context.payload.inputs ?? {};
            const releaseTagInput = (inputs['licenx_release_tag'] || '').trim();
            const overrideImageTag = (inputs['container_image_tag'] || '').trim();

            let releaseTag = releaseTagInput;
            let checkoutRef = releaseTagInput;
            let releaseUrl = '';

            if (releaseTag) {
              try {
                const release = await github.rest.repos.getReleaseByTag({ owner, repo, tag: releaseTag });
                releaseTag = release.data.tag_name || releaseTag;
                checkoutRef = release.data.tag_name || release.data.target_commitish || releaseTag;
                releaseUrl = release.data.html_url || '';
              } catch (error) {
                if (error.status === 404) {
                  await github.rest.git.getRef({ owner, repo, ref: `tags/${releaseTag}` });
                  checkoutRef = releaseTag;
                } else {
                  throw error;
                }
              }
            } else {
              const latest = await github.rest.repos.getLatestRelease({ owner, repo });
              releaseTag = latest.data.tag_name;
              checkoutRef = latest.data.tag_name || latest.data.target_commitish;
              releaseUrl = latest.data.html_url || '';
            }

            if (!checkoutRef) {
              throw new Error('Failed to resolve a git ref for LicenX checkout.');
            }

            const sanitize = (value) => {
              if (!value) return '';
              const trimmed = value.trim();
              if (!trimmed) return '';
              const replaced = trimmed.replace(/[^0-9A-Za-z.+-]/g, '-');
              return replaced ? replaced.toLowerCase() : '';
            };

            const dockerTagCandidate = sanitize(releaseTag) || 'latest';
            const dockerTag = sanitize(overrideImageTag) || dockerTagCandidate;

            core.setOutput('release_tag', releaseTag);
            core.setOutput('checkout_ref', checkoutRef);
            core.setOutput('release_url', releaseUrl);
            core.setOutput('docker_tag', dockerTag);

  deploy_dev:
    name: Deploy Dev
    runs-on: ubuntu-latest
    needs: prepare
    env:
      DEPLOY_STAGE: dev
    steps: &deploy_stage_steps
      - name: Checkout workflow repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Prepare LicenX workspace
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $moduleDir = Join-Path $Env:GITHUB_WORKSPACE '.git/modules' $Env:LICENX_SUBMODULE_PATH
          if (Test-Path $moduleDir) {
            Remove-Item $moduleDir -Recurse -Force
          }
          $submodulePath = Join-Path $Env:GITHUB_WORKSPACE $Env:LICENX_SUBMODULE_PATH
          if (Test-Path $submodulePath) {
            Remove-Item $submodulePath -Recurse -Force
          }

      - name: Export release environment
        shell: pwsh
        env:
          RESOLVED_RELEASE_TAG: ${{ needs.prepare.outputs.release_tag }}
          RESOLVED_RELEASE_URL: ${{ needs.prepare.outputs.release_url }}
          RESOLVED_DOCKER_TAG: ${{ needs.prepare.outputs.docker_tag }}
        run: |
          $ErrorActionPreference = 'Stop'
          if ([string]::IsNullOrWhiteSpace($Env:RESOLVED_RELEASE_TAG)) {
            throw 'Release tag resolution failed.'
          }
          Add-Content -Encoding utf8 -Path $Env:GITHUB_ENV -Value "LICENX_RELEASE_TAG=$($Env:RESOLVED_RELEASE_TAG)"
          if (-not [string]::IsNullOrWhiteSpace($Env:RESOLVED_RELEASE_URL)) {
            Add-Content -Encoding utf8 -Path $Env:GITHUB_ENV -Value "LICENX_RELEASE_URL=$($Env:RESOLVED_RELEASE_URL)"
          }
          $dockerTag = if ([string]::IsNullOrWhiteSpace($Env:RESOLVED_DOCKER_TAG)) { 'latest' } else { $Env:RESOLVED_DOCKER_TAG }
          Add-Content -Encoding utf8 -Path $Env:GITHUB_ENV -Value "TF_VAR_container_image_tag=$dockerTag"

      - name: Checkout LicenX source
        uses: actions/checkout@v4
        with:
          repository: ergosumx/licenx
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          path: ${{ env.LICENX_SUBMODULE_PATH }}
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}

      - name: Configure stage settings
        shell: pwsh
        env:
          STAGE: ${{ env.DEPLOY_STAGE }}
          ACR_ENDPOINT: ${{ secrets.ERGOX_ACR_ENDPOINT }}
          IMAGE_NAME: ${{ env.LICENX_IMAGE_REPOSITORY_NAME }}
        run: |
          $ErrorActionPreference = 'Stop'
          $stage = $Env:STAGE
          if ($stage -notin @('dev', 'prod')) {
            throw "Unsupported stage '$stage'."
          }
          $containerAppName = switch ($stage) {
            'prod' { 'licenx-prod' }
            Default { 'licenx-dev' }
          }
          $endpoint = $Env:ACR_ENDPOINT
          if ([string]::IsNullOrWhiteSpace($endpoint)) {
            throw 'ERGOX_ACR_ENDPOINT secret is required.'
          }
          $endpoint = $endpoint.Trim()
          if ($endpoint.StartsWith('https://')) {
            $endpoint = $endpoint.Substring(8)
          }
          if ($endpoint.StartsWith('http://')) {
            $endpoint = $endpoint.Substring(7)
          }
          $endpoint = $endpoint.TrimEnd('/')
          $imageName = if ([string]::IsNullOrWhiteSpace($Env:IMAGE_NAME)) { 'licenxsrv' } else { $Env:IMAGE_NAME.Trim() }
          $containerImage = "$endpoint/$imageName"
          Add-Content -Encoding utf8 -Path $Env:GITHUB_ENV -Value "TF_VAR_stage=$stage"
          Add-Content -Encoding utf8 -Path $Env:GITHUB_ENV -Value "TF_VAR_container_app_name=$containerAppName"
          Add-Content -Encoding utf8 -Path $Env:GITHUB_ENV -Value "TF_VAR_container_image=$containerImage"

      - name: Summarize deployment inputs
        shell: pwsh
        run: |
          Write-Host "Stage            : $Env:TF_VAR_stage"
          Write-Host "Release tag      : $Env:LICENX_RELEASE_TAG"
          if ($Env:LICENX_RELEASE_URL) {
            Write-Host "Release URL      : $Env:LICENX_RELEASE_URL"
          }
          Write-Host "Container app    : $Env:TF_VAR_container_app_name"
          Write-Host "Image repository : $Env:TF_VAR_container_image"
          Write-Host "Image tag        : $Env:TF_VAR_container_image_tag"

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Terraform init
        working-directory: ${{ env.LICENX_SUBMODULE_PATH }}/.deploy
        run: |
          terraform init \
            -backend-config="resource_group_name=${{ secrets.ERGOX_RG_NAME }}" \
            -backend-config="storage_account_name=${{ env.TERRAFORM_STATE_ACCOUNT }}" \
            -backend-config="container_name=${{ env.TERRAFORM_STATE_CONTAINER }}" \
            -backend-config="key=${{ env.DEPLOY_STAGE }}/licenx/terraform.tfstate"

      - name: Terraform plan
        id: terraform_plan
        working-directory: ${{ env.LICENX_SUBMODULE_PATH }}/.deploy
        run: terraform plan -input=false -out=tfplan

      - name: Show Terraform plan
        working-directory: ${{ env.LICENX_SUBMODULE_PATH }}/.deploy
        run: terraform show -no-color tfplan

      - name: Upload Terraform plan
        if: ${{ !inputs.apply && success() }}
        uses: actions/upload-artifact@v4
        with:
          name: licenx-tfplan-${{ env.DEPLOY_STAGE }}
          path: ${{ env.LICENX_SUBMODULE_PATH }}/.deploy/tfplan
          if-no-files-found: warn

      - name: Terraform apply
        if: ${{ inputs.apply }}
        working-directory: ${{ env.LICENX_SUBMODULE_PATH }}/.deploy
        run: terraform apply -input=false -auto-approve

  validate_simulation:
    name: "Validate Simulation Tests (${{ matrix.os }})"
    runs-on: ${{ matrix.os }}
    needs:
      - deploy_dev
      - prepare
    if: ${{ needs.deploy_dev.result == 'success' && inputs.apply }}
    strategy:
      fail-fast: false
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]
    env:
      ERGOX_LICENX_DEV_OVERRIDE: licenx.dev.override.confirmed
      LICENX_KEY_VAULT_NAME: ${{ secrets.ERGOX_KV_NAME }}
      LICENX_VALIDATION_STAGE: dev
    steps:
      - name: Checkout LicenX source
        uses: actions/checkout@v4
        with:
          repository: ergosumx/licenx
          ref: ${{ needs.prepare.outputs.checkout_ref }}
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}

      - name: Install build prerequisites (Ubuntu)
        if: ${{ matrix.os == 'ubuntu-latest' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y build-essential autoconf automake libtool pkg-config ninja-build libssl-dev libzstd-dev zlib1g-dev

      - name: Install build prerequisites (macOS)
        if: ${{ matrix.os == 'macos-latest' }}
        shell: bash
        run: |
          brew update
          brew install autoconf automake libtool pkg-config ninja coreutils openssl@3 zstd
          OPENSSL_PREFIX=$(brew --prefix openssl@3)
          echo "OPENSSL_ROOT_DIR=$OPENSSL_PREFIX" >> "$GITHUB_ENV"
          echo "PKG_CONFIG_PATH=$OPENSSL_PREFIX/lib/pkgconfig:$PKG_CONFIG_PATH" >> "$GITHUB_ENV"

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Provision signing assets from Key Vault
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          function Get-SecretValue {
            param(
              [string[]]$Names
            )

            foreach ($candidate in $Names) {
              if ([string]::IsNullOrWhiteSpace($candidate)) { continue }
              try {
                $value = & az keyvault secret show --vault-name $Env:LICENX_KEY_VAULT_NAME --name $candidate --query value -o tsv --only-show-errors
                if ($LASTEXITCODE -ne 0) {
                  Write-Host "Secret '$candidate' lookup returned exit code $LASTEXITCODE." -ForegroundColor Yellow
                  continue
                }

                $normalized = ($value | Out-String).Trim()
                if (-not [string]::IsNullOrWhiteSpace($normalized)) {
                  Write-Host "Retrieved secret '$candidate'."
                  return $normalized
                }

                Write-Host "Secret '$candidate' was empty; trying next candidate." -ForegroundColor Yellow
              }
              catch {
                Write-Host "Secret '$candidate' not found; trying next candidate." -ForegroundColor Yellow
              }
            }

            throw "Failed to retrieve any of the candidate secrets: $($Names -join ', ')"
          }

          if ([string]::IsNullOrWhiteSpace($Env:LICENX_KEY_VAULT_NAME)) {
            throw 'LICENX_KEY_VAULT_NAME is not configured.'
          }

          $stage = if ([string]::IsNullOrWhiteSpace($Env:LICENX_VALIDATION_STAGE)) { 'dev' } else { $Env:LICENX_VALIDATION_STAGE.Trim().ToLowerInvariant() }
          $certRoot = Join-Path $PWD (Join-Path '.certs' $stage)
          if (-not (Test-Path $certRoot)) {
            New-Item -ItemType Directory -Path $certRoot -Force | Out-Null
          }

          $privateCandidates = @(
            "$stage-ergox-licenx-private-key",
            "$stage`_ergox_licenx_private_key",
            "licenx-$stage-id-ed25519-private",
            "$stage-licenx-id-ed25519-private"
          )

          $publicCandidates = @(
            "$stage-ergox-licenx-public-key",
            "$stage`_ergox_licenx_public_key",
            "licenx-$stage-id-ed25519-public",
            "$stage-licenx-id-ed25519-public"
          )

          $privateValue = Get-SecretValue -Names $privateCandidates
          $publicValue = Get-SecretValue -Names $publicCandidates

          $privateFile = Join-Path $certRoot 'licenx_private.b64'
          $publicFile = Join-Path $certRoot 'licenx_public.b64'
          Set-Content -LiteralPath $privateFile -Value ($privateValue + "`n") -Encoding ASCII
          Set-Content -LiteralPath $publicFile -Value ($publicValue + "`n") -Encoding ASCII

          $privateBytes = [Convert]::FromBase64String($privateValue)
          if ($privateBytes.Length -ne 64) {
            throw "Private key secret decoded to unexpected length ($($privateBytes.Length) bytes)."
          }

          $hexPayload = -join ($privateBytes | ForEach-Object { $_.ToString('X2') })
          Set-Content -LiteralPath (Join-Path $certRoot 'id_ed25519.private.hex') -Value ($hexPayload + "`n") -Encoding ASCII

          $seedBytes = $privateBytes[0..31]
          $seedHex = -join ($seedBytes | ForEach-Object { $_.ToString('X2') })
          Set-Content -LiteralPath (Join-Path $certRoot 'id_ed25519.seed.hex') -Value ($seedHex + "`n") -Encoding ASCII

          Write-Host "Key material written under $certRoot."

      - name: Verify key artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $stage = if ([string]::IsNullOrWhiteSpace($Env:LICENX_VALIDATION_STAGE)) { 'dev' } else { $Env:LICENX_VALIDATION_STAGE.Trim().ToLowerInvariant() }
          $certRoot = Join-Path $PWD (Join-Path '.certs' $stage)
          $hexPath = Join-Path $certRoot 'id_ed25519.private.hex'
          if (-not (Test-Path $hexPath)) {
            throw "Private hex material missing at $hexPath"
          }
          $hex = (Get-Content -LiteralPath $hexPath -Raw).Trim()
          if ($hex.Length -ne 128) {
            throw "Private hex material should be 128 characters but measured $($hex.Length)."
          }

      - name: Build binaries and prepare simulation sandboxes
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $setupScript = Join-Path $PWD 'simulation_tests/scripts/setup.ps1'
          if (-not (Test-Path $setupScript)) {
            throw "Missing setup script at $setupScript"
          }
          $privateKeyPath = Join-Path $PWD '.certs/dev/id_ed25519.private.hex'
          if (-not (Test-Path $privateKeyPath)) {
            throw "Private key material not found at $privateKeyPath"
          }
          & $setupScript -PrivateKeyPath $privateKeyPath

      - name: Reset simulation outputs
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $resultsPath = Join-Path $PWD 'simulation_tests/results'
          if (Test-Path $resultsPath) {
            Get-ChildItem -Path $resultsPath -File -ErrorAction SilentlyContinue | Remove-Item -Force
            Get-ChildItem -Path $resultsPath -Directory -ErrorAction SilentlyContinue | Remove-Item -Recurse -Force
          }
          Get-ChildItem -Path 'simulation_tests/apps' -Directory | ForEach-Object {
            Get-ChildItem -Path $_.FullName -Filter '*.licenx.leased' -File -ErrorAction SilentlyContinue | Remove-Item -Force
          }

      - name: Execute simulation harness
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $script = Join-Path $PWD 'simulation_tests/scripts/run-all.ps1'
          & $script -EnableDevOverride -ResetLeases -Cycles 3

      - name: Summarize simulation output
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $summaryPath = Join-Path $PWD 'simulation_tests/results/summary.json'
          if (-not (Test-Path $summaryPath)) {
            throw "Missing simulation summary: $summaryPath"
          }
          $summary = Get-Content -LiteralPath $summaryPath -Raw | ConvertFrom-Json
          if (-not $summary) {
            throw 'Simulation summary is empty.'
          }
          ($summary | Sort-Object name) | ConvertTo-Json -Depth 3

      - name: Validate simulation summary against success criteria
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $validator = Join-Path $PWD 'simulation_tests/scripts/validate-summary.ps1'
          & $validator -SummaryPath (Join-Path $PWD 'simulation_tests/results/summary.json')

      - name: Upload simulation artefacts
        if: ${{ always() }}
        uses: actions/upload-artifact@v4
        with:
          name: simulation-results-${{ matrix.os }}
          path: simulation_tests/results
          if-no-files-found: warn

  deploy_prod:
    name: Deploy Prod
    runs-on: ubuntu-latest
    needs:
      - prepare
      - deploy_dev
      - validate_simulation
    if: ${{ needs.deploy_dev.result == 'success' && needs.validate_simulation.result == 'success' && inputs.apply && inputs.dev_only == false && inputs.promote_prod }}
    env:
      DEPLOY_STAGE: prod
    steps: *deploy_stage_steps
