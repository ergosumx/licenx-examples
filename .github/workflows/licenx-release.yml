name: licenx-release

on:
  workflow_dispatch:
    inputs:
      licenx-tag:
        description: Release tag (vX.Y.Z). Required for checkout and artifact versioning.
        required: true
      dockerfile-relative-path:
        description: Optional Dockerfile path relative to licenx submodule
        default: docker/Dockerfile
        required: false

permissions:
  actions: write
  contents: read
  id-token: write
  packages: write

env:
  LICENX_SUBMODULE_PATH: ergox/licenx
  LICENX_SOURCE_DIR: ergox/licenx
  LICENX_BUILD_DIR: ergox/licenx/build
  LICENX_BUILD_CONFIG: Release
  LICENX_ARTIFACT_ROOT: ergox/licenx/artifacts
  LICENX_ENVIRONMENT_INPUT: prod
  LICENX_TAG: ${{ github.event.inputs.licenx-tag }}
  AZURE_STORAGE_ACCOUNT: ergoxbuild
  AZURE_STORAGE_PATH: licenx
  ACR_REGISTRY: ergox
  ACR_LOGIN_SERVER: ergox-ehaeg0gpesc0gag6.azurecr.io
  ACR_IMAGE_NAME: licenxsrv
  WORKFLOW_ARTIFACT_CONTAINER: licenx-workflow-staging
  WORKFLOW_ARTIFACT_PREFIX: workflow-runs/${{ github.run_id }}

jobs:
  build-linux:
    name: Build + Test (Linux)
    runs-on: ubuntu-latest
    env:
      CMAKE_GENERATOR: Ninja
      CMAKE_BUILD_TYPE: Release
      CMAKE_MULTICONFIG: "false"
      ARTIFACT_PLATFORM_SUFFIX: linux
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Prepare LicenX workspace
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $moduleDir = [System.IO.Path]::Combine($Env:GITHUB_WORKSPACE, '.git/modules', $Env:LICENX_SUBMODULE_PATH)
          if (Test-Path $moduleDir) {
            Remove-Item $moduleDir -Recurse -Force
          }
          if (Test-Path $Env:LICENX_SUBMODULE_PATH) {
            Remove-Item $Env:LICENX_SUBMODULE_PATH -Recurse -Force
          }

      - name: Checkout LicenX source
        uses: actions/checkout@v4
        with:
          repository: ergosumx/licenx
          ref: ${{ github.event.inputs.licenx-tag }}
          path: ${{ env.LICENX_SUBMODULE_PATH }}
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}

      - name: Prepare LicenX version metadata
        shell: pwsh
        env:
          INPUT_TAG: ${{ env.LICENX_TAG }}
          BUILD_RUN_ID: ${{ github.run_id }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tagInput = $Env:INPUT_TAG
          if ([string]::IsNullOrWhiteSpace($tagInput)) {
            throw 'LICENX_TAG must be provided for this workflow.'
          }

          $candidate = $tagInput.Trim()

          $fileSafe = $candidate -replace '[^0-9A-Za-z.+-]', '-'
          if ([string]::IsNullOrWhiteSpace($fileSafe)) {
            $fileSafe = '0.0.0'
          }

          $dockerSafe = $fileSafe.ToLowerInvariant()

          $numericSource = $fileSafe
          if ($numericSource.StartsWith('v', [System.StringComparison]::OrdinalIgnoreCase)) {
            $numericSource = $numericSource.Substring(1)
          }

          $numericCore = $numericSource.Split('-', 2)[0]
          if ([string]::IsNullOrWhiteSpace($numericCore)) {
            $numericCore = '0.0.0'
          }

          $segments = $numericCore.Split('.', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($segments.Count -eq 0) {
            $segments = @('0','0','0')
          }

          $intSegments = @()
          foreach ($segment in $segments) {
            if ($segment -match '^[0-9]+$') {
              $intSegments += [int]$segment
            }
            else {
              $intSegments += 0
            }
          }
          while ($intSegments.Count -lt 4) {
            $intSegments += 0
          }

          $major = $intSegments[0]
          $minor = $intSegments[1]
          $patch = $intSegments[2]
          $build = $intSegments[3]

          $runId = $Env:BUILD_RUN_ID
          if (-not [string]::IsNullOrWhiteSpace($runId)) {
            $runId = $runId.Trim()
            if ($runId -match '^[0-9]+$') {
              $build = $runId
            }
            else {
              Write-Host "::warning::Workflow run id '$runId' is not numeric; continuing with parsed build segment $build."
            }
          }

          $semver = "{0}.{1}.{2}" -f $major, $minor, $patch
          $productVersion = "{0}.{1}.{2}.{3}" -f $major, $minor, $patch, $build
          $fileVersion = "{0},{1},{2},{3}" -f $major, $minor, $patch, $build
          $hasTag = 'true'
          $dockerWithBuild = $dockerSafe
          if (-not [string]::IsNullOrWhiteSpace($dockerWithBuild) -and -not [string]::IsNullOrWhiteSpace($build)) {
            $dockerWithBuild = "$dockerWithBuild.$build"
          }

          $versionString = if ([string]::IsNullOrWhiteSpace($dockerWithBuild)) { $fileSafe } else { $dockerWithBuild }

          @(
            "LICENX_VERSION_INPUT=$candidate"
            "LICENX_VERSION_FILESAFE=$fileSafe"
            "LICENX_VERSION_STRING=$versionString"
            "LICENX_VERSION_SEMVER=$semver"
            "LICENX_VERSION_MAJOR=$major"
            "LICENX_VERSION_MINOR=$minor"
            "LICENX_VERSION_PATCH=$patch"
            "LICENX_VERSION_BUILD=$build"
            "LICENX_VERSION_PRODUCT_VERSION=$productVersion"
            "LICENX_VERSION_FILE_VERSION=$fileVersion"
            "LICENX_VERSION_HAS_TAG=$hasTag"
            "LICENX_VERSION_DOCKER_TAG=$dockerSafe"
            "LICENX_VERSION_DOCKER_TAG_WITH_BUILD=$dockerWithBuild"
          ) | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Resolved LicenX version: $fileSafe (semver: $semver)"

      - name: Prepare LicenX version metadata
        shell: pwsh
        env:
          INPUT_TAG: ${{ env.LICENX_TAG }}
          BUILD_RUN_ID: ${{ github.run_id }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tagInput = $Env:INPUT_TAG
          if ([string]::IsNullOrWhiteSpace($tagInput)) {
            throw 'LICENX_TAG must be provided for this workflow.'
          }

          $candidate = $tagInput.Trim()

          $fileSafe = $candidate -replace '[^0-9A-Za-z.+-]', '-'
          if ([string]::IsNullOrWhiteSpace($fileSafe)) {
            $fileSafe = '0.0.0'
          }

          $dockerSafe = $fileSafe.ToLowerInvariant()

          $numericSource = $fileSafe
          if ($numericSource.StartsWith('v', [System.StringComparison]::OrdinalIgnoreCase)) {
            $numericSource = $numericSource.Substring(1)
          }

          $numericCore = $numericSource.Split('-', 2)[0]
          if ([string]::IsNullOrWhiteSpace($numericCore)) {
            $numericCore = '0.0.0'
          }

          $segments = $numericCore.Split('.', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($segments.Count -eq 0) {
            $segments = @('0','0','0')
          }

          $intSegments = @()
          foreach ($segment in $segments) {
            if ($segment -match '^[0-9]+$') {
              $intSegments += [int]$segment
            }
            else {
              $intSegments += 0
            }
          }
          while ($intSegments.Count -lt 4) {
            $intSegments += 0
          }

          $major = $intSegments[0]
          $minor = $intSegments[1]
          $patch = $intSegments[2]
          $build = $intSegments[3]

          $runId = $Env:BUILD_RUN_ID
          if (-not [string]::IsNullOrWhiteSpace($runId)) {
            $runId = $runId.Trim()
            if ($runId -match '^[0-9]+$') {
              $build = $runId
            }
            else {
              Write-Host "::warning::Workflow run id '$runId' is not numeric; continuing with parsed build segment $build."
            }
          }

          $semver = "{0}.{1}.{2}" -f $major, $minor, $patch
          $productVersion = "{0}.{1}.{2}.{3}" -f $major, $minor, $patch, $build
          $fileVersion = "{0},{1},{2},{3}" -f $major, $minor, $patch, $build
          $hasTag = if ([string]::IsNullOrWhiteSpace($tagInput)) { 'false' } else { 'true' }
          $dockerWithBuild = $dockerSafe
          if (-not [string]::IsNullOrWhiteSpace($dockerWithBuild) -and -not [string]::IsNullOrWhiteSpace($build)) {
            $dockerWithBuild = "$dockerWithBuild.$build"
          }

          $versionString = if ([string]::IsNullOrWhiteSpace($dockerWithBuild)) { $fileSafe } else { $dockerWithBuild }

          @(
            "LICENX_VERSION_INPUT=$candidate"
            "LICENX_VERSION_FILESAFE=$fileSafe"
            "LICENX_VERSION_STRING=$versionString"
            "LICENX_VERSION_SEMVER=$semver"
            "LICENX_VERSION_MAJOR=$major"
            "LICENX_VERSION_MINOR=$minor"
            "LICENX_VERSION_PATCH=$patch"
            "LICENX_VERSION_BUILD=$build"
            "LICENX_VERSION_PRODUCT_VERSION=$productVersion"
            "LICENX_VERSION_FILE_VERSION=$fileVersion"
            "LICENX_VERSION_HAS_TAG=$hasTag"
            "LICENX_VERSION_DOCKER_TAG=$dockerSafe"
            "LICENX_VERSION_DOCKER_TAG_WITH_BUILD=$dockerWithBuild"
          ) | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Resolved LicenX version: $fileSafe (semver: $semver)"

      - name: Prepare LicenX version metadata
        shell: pwsh
        env:
          INPUT_TAG: ${{ env.LICENX_TAG }}
          BUILD_RUN_ID: ${{ github.run_id }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tagInput = $Env:INPUT_TAG
          if ([string]::IsNullOrWhiteSpace($tagInput)) {
            throw 'LICENX_TAG must be provided for this workflow.'
          }

          $candidate = $tagInput.Trim()

          $fileSafe = $candidate -replace '[^0-9A-Za-z.+-]', '-'
          if ([string]::IsNullOrWhiteSpace($fileSafe)) {
            $fileSafe = '0.0.0'
          }

          $dockerSafe = $fileSafe.ToLowerInvariant()

          $numericSource = $fileSafe
          if ($numericSource.StartsWith('v', [System.StringComparison]::OrdinalIgnoreCase)) {
            $numericSource = $numericSource.Substring(1)
          }

          $numericCore = $numericSource.Split('-', 2)[0]
          if ([string]::IsNullOrWhiteSpace($numericCore)) {
            $numericCore = '0.0.0'
          }

          $segments = $numericCore.Split('.', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($segments.Count -eq 0) {
            $segments = @('0','0','0')
          }

          $intSegments = @()
          foreach ($segment in $segments) {
            if ($segment -match '^[0-9]+$') {
              $intSegments += [int]$segment
            }
            else {
              $intSegments += 0
            }
          }
          while ($intSegments.Count -lt 4) {
            $intSegments += 0
          }

          $major = $intSegments[0]
          $minor = $intSegments[1]
          $patch = $intSegments[2]
          $build = $intSegments[3]

          $runId = $Env:BUILD_RUN_ID
          if (-not [string]::IsNullOrWhiteSpace($runId)) {
            $runId = $runId.Trim()
            if ($runId -match '^[0-9]+$') {
              $build = $runId
            }
            else {
              Write-Host "::warning::Workflow run id '$runId' is not numeric; continuing with parsed build segment $build."
            }
          }

          $semver = "{0}.{1}.{2}" -f $major, $minor, $patch
          $productVersion = "{0}.{1}.{2}.{3}" -f $major, $minor, $patch, $build
          $fileVersion = "{0},{1},{2},{3}" -f $major, $minor, $patch, $build
          $hasTag = 'true'
          $dockerWithBuild = $dockerSafe
          if (-not [string]::IsNullOrWhiteSpace($dockerWithBuild) -and -not [string]::IsNullOrWhiteSpace($build)) {
            $dockerWithBuild = "$dockerWithBuild.$build"
          }

          $versionString = if ([string]::IsNullOrWhiteSpace($dockerWithBuild)) { $fileSafe } else { $dockerWithBuild }

          @(
            "LICENX_VERSION_INPUT=$candidate"
            "LICENX_VERSION_FILESAFE=$fileSafe"
            "LICENX_VERSION_STRING=$versionString"
            "LICENX_VERSION_SEMVER=$semver"
            "LICENX_VERSION_MAJOR=$major"
            "LICENX_VERSION_MINOR=$minor"
            "LICENX_VERSION_PATCH=$patch"
            "LICENX_VERSION_BUILD=$build"
            "LICENX_VERSION_PRODUCT_VERSION=$productVersion"
            "LICENX_VERSION_FILE_VERSION=$fileVersion"
            "LICENX_VERSION_HAS_TAG=$hasTag"
            "LICENX_VERSION_DOCKER_TAG=$dockerSafe"
            "LICENX_VERSION_DOCKER_TAG_WITH_BUILD=$dockerWithBuild"
          ) | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Resolved LicenX version: $fileSafe (semver: $semver)"

      - name: Prepare LicenX version metadata
        shell: pwsh
        env:
          INPUT_TAG: ${{ env.LICENX_TAG }}
          BUILD_RUN_ID: ${{ github.run_id }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tagInput = $Env:INPUT_TAG
          if ([string]::IsNullOrWhiteSpace($tagInput)) {
            throw 'LICENX_TAG must be provided for this workflow.'
          }

          $candidate = $tagInput.Trim()

          $fileSafe = $candidate -replace '[^0-9A-Za-z.+-]', '-'
          if ([string]::IsNullOrWhiteSpace($fileSafe)) {
            $fileSafe = '0.0.0'
          }

          $dockerSafe = $fileSafe.ToLowerInvariant()

          $numericSource = $fileSafe
          if ($numericSource.StartsWith('v', [System.StringComparison]::OrdinalIgnoreCase)) {
            $numericSource = $numericSource.Substring(1)
          }

          $numericCore = $numericSource.Split('-', 2)[0]
          if ([string]::IsNullOrWhiteSpace($numericCore)) {
            $numericCore = '0.0.0'
          }

          $segments = $numericCore.Split('.', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($segments.Count -eq 0) {
            $segments = @('0','0','0')
          }

          $intSegments = @()
          foreach ($segment in $segments) {
            if ($segment -match '^[0-9]+$') {
              $intSegments += [int]$segment
            }
            else {
              $intSegments += 0
            }
          }
          while ($intSegments.Count -lt 4) {
            $intSegments += 0
          }

          $major = $intSegments[0]
          $minor = $intSegments[1]
          $patch = $intSegments[2]
          $build = $intSegments[3]

          $runId = $Env:BUILD_RUN_ID
          if (-not [string]::IsNullOrWhiteSpace($runId)) {
            $runId = $runId.Trim()
            if ($runId -match '^[0-9]+$') {
              $build = $runId
            }
            else {
              Write-Host "::warning::Workflow run id '$runId' is not numeric; continuing with parsed build segment $build."
            }
          }

          $semver = "{0}.{1}.{2}" -f $major, $minor, $patch
          $productVersion = "{0}.{1}.{2}.{3}" -f $major, $minor, $patch, $build
          $fileVersion = "{0},{1},{2},{3}" -f $major, $minor, $patch, $build
          $hasTag = 'true'
          $dockerWithBuild = $dockerSafe
          if (-not [string]::IsNullOrWhiteSpace($dockerWithBuild) -and -not [string]::IsNullOrWhiteSpace($build)) {
            $dockerWithBuild = "$dockerWithBuild.$build"
          }

          $versionString = if ([string]::IsNullOrWhiteSpace($dockerWithBuild)) { $fileSafe } else { $dockerWithBuild }

          @(
            "LICENX_VERSION_INPUT=$candidate"
            "LICENX_VERSION_FILESAFE=$fileSafe"
            "LICENX_VERSION_STRING=$versionString"
            "LICENX_VERSION_SEMVER=$semver"
            "LICENX_VERSION_MAJOR=$major"
            "LICENX_VERSION_MINOR=$minor"
            "LICENX_VERSION_PATCH=$patch"
            "LICENX_VERSION_BUILD=$build"
            "LICENX_VERSION_PRODUCT_VERSION=$productVersion"
            "LICENX_VERSION_FILE_VERSION=$fileVersion"
            "LICENX_VERSION_HAS_TAG=$hasTag"
            "LICENX_VERSION_DOCKER_TAG=$dockerSafe"
            "LICENX_VERSION_DOCKER_TAG_WITH_BUILD=$dockerWithBuild"
          ) | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Resolved LicenX version: $fileSafe (semver: $semver)"

      - name: Install build dependencies
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            ninja-build \
            pkg-config \
            autoconf \
            automake \
            libtool \
            m4 \
            libcurl4-openssl-dev \
            libsodium-dev \
            libssl-dev \
            zlib1g-dev

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Configure LicenX build
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $cmakeArgs = @(
            '-S', $Env:LICENX_SOURCE_DIR,
            '-B', $Env:LICENX_BUILD_DIR,
            '-G', $Env:CMAKE_GENERATOR,
            "-DLICENX_ENVIRONMENT=$Env:LICENX_ENVIRONMENT_INPUT",
            '-DLICENX_BUILD_TESTS=ON',
            '-DLICENX_USE_VENDORED_DEPS=ON',
            '-DLICENX_BUILD_GATEWAY=OFF'
          )
          if ($Env:CMAKE_MULTICONFIG -ne 'true') {
            $cmakeArgs += "-DCMAKE_BUILD_TYPE=$Env:CMAKE_BUILD_TYPE"
          }
          if ($Env:CMAKE_GENERATOR_PLATFORM) {
            $cmakeArgs += '-A'
            $cmakeArgs += $Env:CMAKE_GENERATOR_PLATFORM
          }
          if ($Env:CMAKE_TOOLCHAIN_FILE) {
            $cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=$Env:CMAKE_TOOLCHAIN_FILE"
          }
          if ($Env:CMAKE_PREFIX_PATH) {
            $cmakeArgs += "-DCMAKE_PREFIX_PATH=$Env:CMAKE_PREFIX_PATH"
          }
          if ($Env:LICENX_VERSION_STRING) {
            $cmakeArgs += "-DLICENX_VERSION_STRING=$Env:LICENX_VERSION_STRING"
          }
          cmake @cmakeArgs

      - name: Build LicenX artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $args = @('--build', $Env:LICENX_BUILD_DIR)
          if ($multiConfig) { $args += @('--config', $Env:LICENX_BUILD_CONFIG) }
          cmake @args

      - name: Run unit tests
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Env:LICENX_MACHINE_ID_OVERRIDE = '0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $ctestArgs = @('--test-dir', $Env:LICENX_BUILD_DIR, '--output-on-failure')
          if ($multiConfig) { $ctestArgs += @('-C', $Env:LICENX_BUILD_CONFIG) }
          ctest @ctestArgs

      - name: Package release artifacts
        id: package
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $workspace = $Env:GITHUB_WORKSPACE
          $buildDir = Join-Path $workspace $Env:LICENX_BUILD_DIR
          $artifactsRoot = Join-Path $workspace $Env:LICENX_ARTIFACT_ROOT
          $publishDir = Join-Path $artifactsRoot 'publish'
          $cliDir = Join-Path $artifactsRoot 'admin-cli'
          $sdkDir = Join-Path $artifactsRoot 'sdk'
          $sdkLibDir = Join-Path $sdkDir 'lib'
          $sdkIncludeDir = Join-Path $sdkDir 'include'

          $directories = @($artifactsRoot, $publishDir, $cliDir, $sdkDir, $sdkLibDir, $sdkIncludeDir)
          foreach ($dir in $directories) {
            if (-not (Test-Path $dir)) {
              New-Item -ItemType Directory -Path $dir | Out-Null
            }
            else {
              Get-ChildItem -Path $dir -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            }
          }

          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $outputDir = if ($multiConfig) { Join-Path $buildDir $Env:LICENX_BUILD_CONFIG } else { $buildDir }

          $cliCandidates = @(
            (Join-Path -Path $outputDir -ChildPath 'licenx_admin_cli.exe')
            (Join-Path -Path $outputDir -ChildPath 'licenx_admin_cli')
            (Join-Path -Path $buildDir -ChildPath 'licenx_admin_cli.exe')
            (Join-Path -Path $buildDir -ChildPath 'licenx_admin_cli')
          )

          $cliPath = $null
          foreach ($candidate in $cliCandidates) {
            if (Test-Path $candidate) {
              $cliPath = $candidate
              break
            }
          }

          if (-not $cliPath) {
            throw "Expected CLI artifact not found. Checked: $($cliCandidates -join ', ')"
          }

          $versionSegment = $Env:LICENX_VERSION_FILESAFE
          $useVersionedNames = -not [string]::IsNullOrWhiteSpace($versionSegment)

          $cliSourceName = Split-Path -Path $cliPath -Leaf
          $cliBase = [System.IO.Path]::GetFileNameWithoutExtension($cliSourceName)
          $cliExt = [System.IO.Path]::GetExtension($cliSourceName)
          if ($useVersionedNames) {
            $cliDestName = if ([string]::IsNullOrEmpty($cliExt)) { "$cliBase-$versionSegment" } else { "$cliBase-$versionSegment$cliExt" }
          }
          else {
            $cliDestName = $cliSourceName
          }
          $cliDestPath = Join-Path $cliDir $cliDestName
          Copy-Item $cliPath $cliDestPath -Force

          $libraryPatterns = @('licenx*.lib','licenx*.dll','licenx*.exp','licenx*.pdb','liblicenx*.a','liblicenx*.so','liblicenx*.dylib')
          $libraries = @()
          foreach ($pattern in $libraryPatterns) {
            $libraries += Get-ChildItem -Path $outputDir -Recurse -File -Filter $pattern -ErrorAction SilentlyContinue
          }
          $libraries = $libraries | Sort-Object -Property FullName -Unique
          if ($libraries.Count -eq 0) {
            throw "No LicenX library artifacts matching expected patterns were found in $outputDir"
          }
          foreach ($lib in $libraries) {
            $destName = $lib.Name
            if ($useVersionedNames) {
              $base = [System.IO.Path]::GetFileNameWithoutExtension($lib.Name)
              $ext = $lib.Extension
              $destName = if ([string]::IsNullOrEmpty($ext)) { "$base-$versionSegment" } else { "$base-$versionSegment$ext" }
            }
            Copy-Item $lib.FullName (Join-Path $sdkLibDir $destName) -Force
          }

          $includeSource = Join-Path $workspace (Join-Path $Env:LICENX_SOURCE_DIR 'include')
          if (-not (Test-Path $includeSource)) {
            throw "Header directory not found at $includeSource"
          }
          Copy-Item (Join-Path $includeSource '*') $sdkIncludeDir -Recurse -Force

          $readmeSource = Join-Path $workspace (Join-Path $Env:LICENX_SOURCE_DIR 'README.md')
          if (Test-Path $readmeSource) {
            Copy-Item $readmeSource $sdkDir -Force
          }

          $platform = $Env:ARTIFACT_PLATFORM_SUFFIX
          $artifactSuffix = if ($useVersionedNames) { "$platform-$versionSegment" } else { $platform }
          $cliZip = Join-Path $publishDir "licenx-admin-cli-$artifactSuffix.zip"
          $sdkZip = Join-Path $publishDir "licenx-sdk-$artifactSuffix.zip"

          if (Test-Path $cliZip) { Remove-Item $cliZip -Force }
          if (Test-Path $sdkZip) { Remove-Item $sdkZip -Force }

          Compress-Archive -Path (Join-Path $cliDir '*') -DestinationPath $cliZip -Force
          Compress-Archive -Path (Join-Path $sdkDir '*') -DestinationPath $sdkZip -Force

          "publish-dir=$publishDir" | Out-File -FilePath $Env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Azure login (artifact staging)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Stage packaged artifacts in Azure Storage
        shell: pwsh
        env:
          PUBLISH_DIR: ${{ steps.package.outputs.publish-dir }}
        run: |
          $ErrorActionPreference = 'Stop'
          $publishDir = $Env:PUBLISH_DIR
          if ([string]::IsNullOrWhiteSpace($publishDir) -or -not (Test-Path $publishDir)) {
            throw "Publish directory $publishDir not found."
          }

          $container = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_CONTAINER)) {
            'licenx-workflow-staging'
          }
          else {
            $Env:WORKFLOW_ARTIFACT_CONTAINER.Trim()
          }

          $prefixRoot = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_PREFIX)) {
            "workflow-runs/$($Env:GITHUB_RUN_ID)"
          }
          else {
            $Env:WORKFLOW_ARTIFACT_PREFIX.Trim().TrimEnd('/')
          }

          $platform = if ([string]::IsNullOrWhiteSpace($Env:ARTIFACT_PLATFORM_SUFFIX)) {
            'linux'
          }
          else {
            $Env:ARTIFACT_PLATFORM_SUFFIX.Trim()
          }

          $destinationPath = "$prefixRoot/$platform"

          az storage container create `
            --name $container `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --only-show-errors | Out-Null

          az storage blob upload-batch `
            --destination $container `
            --source $publishDir `
            --destination-path $destinationPath `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --pattern '*' `
            --overwrite `
            --no-progress | Out-Null

          Write-Host "Staged $publishDir to Azure storage path $container/$destinationPath"

  build-macos:
    name: Build + Test (macOS)
    runs-on: macos-latest
    env:
      CMAKE_GENERATOR: Ninja
      CMAKE_BUILD_TYPE: Release
      CMAKE_MULTICONFIG: "false"
      ARTIFACT_PLATFORM_SUFFIX: macos
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Prepare LicenX workspace
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $moduleDir = [System.IO.Path]::Combine($Env:GITHUB_WORKSPACE, '.git/modules', $Env:LICENX_SUBMODULE_PATH)
          if (Test-Path $moduleDir) {
            Remove-Item $moduleDir -Recurse -Force
          }
          if (Test-Path $Env:LICENX_SUBMODULE_PATH) {
            Remove-Item $Env:LICENX_SUBMODULE_PATH -Recurse -Force
          }

      - name: Checkout LicenX source
        uses: actions/checkout@v4
        with:
          repository: ergosumx/licenx
          ref: ${{ github.event.inputs.licenx-tag }}
          path: ${{ env.LICENX_SUBMODULE_PATH }}
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}

      - name: Prepare LicenX version metadata
        shell: pwsh
        env:
          INPUT_TAG: ${{ env.LICENX_TAG }}
          BUILD_RUN_ID: ${{ github.run_id }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tagInput = $Env:INPUT_TAG
          if ([string]::IsNullOrWhiteSpace($tagInput)) {
            throw 'LICENX_TAG must be provided for this workflow.'
          }

          $candidate = $tagInput.Trim()

          $fileSafe = $candidate -replace '[^0-9A-Za-z.+-]', '-'
          if ([string]::IsNullOrWhiteSpace($fileSafe)) {
            $fileSafe = '0.0.0'
          }

          $dockerSafe = $fileSafe.ToLowerInvariant()

          $numericSource = $fileSafe
          if ($numericSource.StartsWith('v', [System.StringComparison]::OrdinalIgnoreCase)) {
            $numericSource = $numericSource.Substring(1)
          }

          $numericCore = $numericSource.Split('-', 2)[0]
          if ([string]::IsNullOrWhiteSpace($numericCore)) {
            $numericCore = '0.0.0'
          }

          $segments = $numericCore.Split('.', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($segments.Count -eq 0) {
            $segments = @('0','0','0')
          }

          $intSegments = @()
          foreach ($segment in $segments) {
            if ($segment -match '^[0-9]+$') {
              $intSegments += [int]$segment
            }
            else {
              $intSegments += 0
            }
          }
          while ($intSegments.Count -lt 4) {
            $intSegments += 0
          }

          $major = $intSegments[0]
          $minor = $intSegments[1]
          $patch = $intSegments[2]
          $build = $intSegments[3]

          $runId = $Env:BUILD_RUN_ID
          if (-not [string]::IsNullOrWhiteSpace($runId)) {
            $runId = $runId.Trim()
            if ($runId -match '^[0-9]+$') {
              $build = $runId
            }
            else {
              Write-Host "::warning::Workflow run id '$runId' is not numeric; continuing with parsed build segment $build."
            }
          }

          $semver = "{0}.{1}.{2}" -f $major, $minor, $patch
          $productVersion = "{0}.{1}.{2}.{3}" -f $major, $minor, $patch, $build
          $fileVersion = "{0},{1},{2},{3}" -f $major, $minor, $patch, $build
          $hasTag = 'true'
          $dockerWithBuild = $dockerSafe
          if (-not [string]::IsNullOrWhiteSpace($dockerWithBuild) -and -not [string]::IsNullOrWhiteSpace($build)) {
            $dockerWithBuild = "$dockerWithBuild.$build"
          }

          $versionString = if ([string]::IsNullOrWhiteSpace($dockerWithBuild)) { $fileSafe } else { $dockerWithBuild }

          @(
            "LICENX_VERSION_INPUT=$candidate"
            "LICENX_VERSION_FILESAFE=$fileSafe"
            "LICENX_VERSION_STRING=$versionString"
            "LICENX_VERSION_SEMVER=$semver"
            "LICENX_VERSION_MAJOR=$major"
            "LICENX_VERSION_MINOR=$minor"
            "LICENX_VERSION_PATCH=$patch"
            "LICENX_VERSION_BUILD=$build"
            "LICENX_VERSION_PRODUCT_VERSION=$productVersion"
            "LICENX_VERSION_FILE_VERSION=$fileVersion"
            "LICENX_VERSION_HAS_TAG=$hasTag"
            "LICENX_VERSION_DOCKER_TAG=$dockerSafe"
            "LICENX_VERSION_DOCKER_TAG_WITH_BUILD=$dockerWithBuild"
          ) | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Resolved LicenX version: $fileSafe (semver: $semver)"

      - name: Install build dependencies
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install ninja pkg-config curl libsodium autoconf automake libtool
          curl_prefix="$(brew --prefix curl)"
          sodium_prefix="$(brew --prefix libsodium)"
          echo "PKG_CONFIG_PATH=$curl_prefix/lib/pkgconfig:$sodium_prefix/lib/pkgconfig${PKG_CONFIG_PATH:+:$PKG_CONFIG_PATH}" >> "$GITHUB_ENV"

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Configure LicenX build
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $cmakeArgs = @(
            '-S', $Env:LICENX_SOURCE_DIR,
            '-B', $Env:LICENX_BUILD_DIR,
            '-G', $Env:CMAKE_GENERATOR,
            "-DLICENX_ENVIRONMENT=$Env:LICENX_ENVIRONMENT_INPUT",
            '-DLICENX_BUILD_TESTS=ON',
            '-DLICENX_USE_VENDORED_DEPS=ON',
            '-DLICENX_BUILD_GATEWAY=OFF'
          )
          if ($Env:CMAKE_MULTICONFIG -ne 'true') {
            $cmakeArgs += "-DCMAKE_BUILD_TYPE=$Env:CMAKE_BUILD_TYPE"
          }
          if ($Env:CMAKE_GENERATOR_PLATFORM) {
            $cmakeArgs += '-A'
            $cmakeArgs += $Env:CMAKE_GENERATOR_PLATFORM
          }
          if ($Env:CMAKE_TOOLCHAIN_FILE) {
            $cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=$Env:CMAKE_TOOLCHAIN_FILE"
          }
          if ($Env:CMAKE_PREFIX_PATH) {
            $cmakeArgs += "-DCMAKE_PREFIX_PATH=$Env:CMAKE_PREFIX_PATH"
          }
          if ($Env:LICENX_VERSION_STRING) {
            $cmakeArgs += "-DLICENX_VERSION_STRING=$Env:LICENX_VERSION_STRING"
          }
          cmake @cmakeArgs

      - name: Build LicenX artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $args = @('--build', $Env:LICENX_BUILD_DIR)
          if ($multiConfig) { $args += @('--config', $Env:LICENX_BUILD_CONFIG) }
          cmake @args

      - name: Run unit tests
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Env:LICENX_MACHINE_ID_OVERRIDE = '0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $ctestArgs = @('--test-dir', $Env:LICENX_BUILD_DIR, '--output-on-failure')
          if ($multiConfig) { $ctestArgs += @('-C', $Env:LICENX_BUILD_CONFIG) }
          ctest @ctestArgs

      - name: Package release artifacts
        id: package
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $workspace = $Env:GITHUB_WORKSPACE
          $buildDir = Join-Path $workspace $Env:LICENX_BUILD_DIR
          $artifactsRoot = Join-Path $workspace $Env:LICENX_ARTIFACT_ROOT
          $publishDir = Join-Path $artifactsRoot 'publish'
          $cliDir = Join-Path $artifactsRoot 'admin-cli'
          $sdkDir = Join-Path $artifactsRoot 'sdk'
          $sdkLibDir = Join-Path $sdkDir 'lib'
          $sdkIncludeDir = Join-Path $sdkDir 'include'

          $directories = @($artifactsRoot, $publishDir, $cliDir, $sdkDir, $sdkLibDir, $sdkIncludeDir)
          foreach ($dir in $directories) {
            if (-not (Test-Path $dir)) {
              New-Item -ItemType Directory -Path $dir | Out-Null
            }
            else {
              Get-ChildItem -Path $dir -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            }
          }

          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $outputDir = if ($multiConfig) { Join-Path $buildDir $Env:LICENX_BUILD_CONFIG } else { $buildDir }

          $cliCandidates = @(
            (Join-Path -Path $outputDir -ChildPath 'licenx_admin_cli.exe')
            (Join-Path -Path $outputDir -ChildPath 'licenx_admin_cli')
            (Join-Path -Path $buildDir -ChildPath 'licenx_admin_cli.exe')
            (Join-Path -Path $buildDir -ChildPath 'licenx_admin_cli')
          )

          $cliPath = $null
          foreach ($candidate in $cliCandidates) {
            if (Test-Path $candidate) {
              $cliPath = $candidate
              break
            }
          }

          if (-not $cliPath) {
            throw "Expected CLI artifact not found. Checked: $($cliCandidates -join ', ')"
          }

          $versionSegment = $Env:LICENX_VERSION_FILESAFE
          $useVersionedNames = -not [string]::IsNullOrWhiteSpace($versionSegment)

          $cliSourceName = Split-Path -Path $cliPath -Leaf
          $cliBase = [System.IO.Path]::GetFileNameWithoutExtension($cliSourceName)
          $cliExt = [System.IO.Path]::GetExtension($cliSourceName)
          if ($useVersionedNames) {
            $cliDestName = if ([string]::IsNullOrEmpty($cliExt)) { "$cliBase-$versionSegment" } else { "$cliBase-$versionSegment$cliExt" }
          }
          else {
            $cliDestName = $cliSourceName
          }
          $cliDestPath = Join-Path $cliDir $cliDestName
          Copy-Item $cliPath $cliDestPath -Force

          $libraryPatterns = @('licenx*.lib','licenx*.dll','licenx*.exp','licenx*.pdb','liblicenx*.a','liblicenx*.so','liblicenx*.dylib')
          $libraries = @()
          foreach ($pattern in $libraryPatterns) {
            $libraries += Get-ChildItem -Path $outputDir -Recurse -File -Filter $pattern -ErrorAction SilentlyContinue
          }
          $libraries = $libraries | Sort-Object -Property FullName -Unique
          if ($libraries.Count -eq 0) {
            throw "No LicenX library artifacts matching expected patterns were found in $outputDir"
          }
          foreach ($lib in $libraries) {
            $destName = $lib.Name
            if ($useVersionedNames) {
              $base = [System.IO.Path]::GetFileNameWithoutExtension($lib.Name)
              $ext = $lib.Extension
              $destName = if ([string]::IsNullOrEmpty($ext)) { "$base-$versionSegment" } else { "$base-$versionSegment$ext" }
            }
            Copy-Item $lib.FullName (Join-Path $sdkLibDir $destName) -Force
          }

          $includeSource = Join-Path $workspace (Join-Path $Env:LICENX_SOURCE_DIR 'include')
          if (-not (Test-Path $includeSource)) {
            throw "Header directory not found at $includeSource"
          }
          Copy-Item (Join-Path $includeSource '*') $sdkIncludeDir -Recurse -Force

          $readmeSource = Join-Path $workspace (Join-Path $Env:LICENX_SOURCE_DIR 'README.md')
          if (Test-Path $readmeSource) {
            Copy-Item $readmeSource $sdkDir -Force
          }

          $platform = $Env:ARTIFACT_PLATFORM_SUFFIX
          $artifactSuffix = if ($useVersionedNames) { "$platform-$versionSegment" } else { $platform }
          $cliZip = Join-Path $publishDir "licenx-admin-cli-$artifactSuffix.zip"
          $sdkZip = Join-Path $publishDir "licenx-sdk-$artifactSuffix.zip"

          if (Test-Path $cliZip) { Remove-Item $cliZip -Force }
          if (Test-Path $sdkZip) { Remove-Item $sdkZip -Force }

          Compress-Archive -Path (Join-Path $cliDir '*') -DestinationPath $cliZip -Force
          Compress-Archive -Path (Join-Path $sdkDir '*') -DestinationPath $sdkZip -Force

          "publish-dir=$publishDir" | Out-File -FilePath $Env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Azure login (artifact staging)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Stage packaged artifacts in Azure Storage
        shell: pwsh
        env:
          PUBLISH_DIR: ${{ steps.package.outputs.publish-dir }}
        run: |
          $ErrorActionPreference = 'Stop'
          $publishDir = $Env:PUBLISH_DIR
          if ([string]::IsNullOrWhiteSpace($publishDir) -or -not (Test-Path $publishDir)) {
            throw "Publish directory $publishDir not found."
          }

          $container = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_CONTAINER)) {
            'licenx-workflow-staging'
          }
          else {
            $Env:WORKFLOW_ARTIFACT_CONTAINER.Trim()
          }

          $prefixRoot = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_PREFIX)) {
            "workflow-runs/$($Env:GITHUB_RUN_ID)"
          }
          else {
            $Env:WORKFLOW_ARTIFACT_PREFIX.Trim().TrimEnd('/')
          }

          $platform = if ([string]::IsNullOrWhiteSpace($Env:ARTIFACT_PLATFORM_SUFFIX)) {
            'macos'
          }
          else {
            $Env:ARTIFACT_PLATFORM_SUFFIX.Trim()
          }

          $destinationPath = "$prefixRoot/$platform"

          az storage container create `
            --name $container `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --only-show-errors | Out-Null

          az storage blob upload-batch `
            --destination $container `
            --source $publishDir `
            --destination-path $destinationPath `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --pattern '*' `
            --overwrite `
            --no-progress | Out-Null

          Write-Host "Staged $publishDir to Azure storage path $container/$destinationPath"

  build-windows:
    name: Build + Test (Windows)
    runs-on: windows-latest
    env:
      CMAKE_GENERATOR: "Visual Studio 17 2022"
      CMAKE_GENERATOR_PLATFORM: x64
      CMAKE_BUILD_TYPE: Release
      CMAKE_MULTICONFIG: "true"
      ARTIFACT_PLATFORM_SUFFIX: windows
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Prepare LicenX workspace
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $moduleDir = [System.IO.Path]::Combine($Env:GITHUB_WORKSPACE, '.git/modules', $Env:LICENX_SUBMODULE_PATH)
          if (Test-Path $moduleDir) {
            Remove-Item $moduleDir -Recurse -Force
          }
          if (Test-Path $Env:LICENX_SUBMODULE_PATH) {
            Remove-Item $Env:LICENX_SUBMODULE_PATH -Recurse -Force
          }

      - name: Checkout LicenX source
        uses: actions/checkout@v4
        with:
          repository: ergosumx/licenx
          ref: ${{ github.event.inputs.licenx-tag }}
          path: ${{ env.LICENX_SUBMODULE_PATH }}
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Configure LicenX build
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $cmakeArgs = @(
            '-S', $Env:LICENX_SOURCE_DIR,
            '-B', $Env:LICENX_BUILD_DIR,
            '-G', $Env:CMAKE_GENERATOR,
            "-DLICENX_ENVIRONMENT=$Env:LICENX_ENVIRONMENT_INPUT",
            '-DLICENX_BUILD_TESTS=ON',
            '-DLICENX_USE_VENDORED_DEPS=ON',
            '-DLICENX_BUILD_GATEWAY=OFF'
          )
          if ($Env:CMAKE_MULTICONFIG -ne 'true') {
            $cmakeArgs += "-DCMAKE_BUILD_TYPE=$Env:CMAKE_BUILD_TYPE"
          }
          if ($Env:CMAKE_GENERATOR_PLATFORM) {
            $cmakeArgs += '-A'
            $cmakeArgs += $Env:CMAKE_GENERATOR_PLATFORM
          }
          if ($Env:CMAKE_TOOLCHAIN_FILE) {
            $cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=$Env:CMAKE_TOOLCHAIN_FILE"
          }
          if ($Env:CMAKE_PREFIX_PATH) {
            $cmakeArgs += "-DCMAKE_PREFIX_PATH=$Env:CMAKE_PREFIX_PATH"
          }
          if ($Env:LICENX_VERSION_STRING) {
            $cmakeArgs += "-DLICENX_VERSION_STRING=$Env:LICENX_VERSION_STRING"
          }
          cmake @cmakeArgs

      - name: Build LicenX artifacts
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $args = @('--build', $Env:LICENX_BUILD_DIR)
          if ($multiConfig) { $args += @('--config', $Env:LICENX_BUILD_CONFIG) }
          cmake @args

      - name: Run unit tests
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $Env:LICENX_MACHINE_ID_OVERRIDE = '0123456789ABCDEFFEDCBA98765432100123456789ABCDEFFEDCBA9876543210'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $ctestArgs = @('--test-dir', $Env:LICENX_BUILD_DIR, '--output-on-failure')
          if ($multiConfig) { $ctestArgs += @('-C', $Env:LICENX_BUILD_CONFIG) }
          ctest @ctestArgs

      - name: Package release artifacts
        id: package
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $workspace = $Env:GITHUB_WORKSPACE
          $buildDir = Join-Path $workspace $Env:LICENX_BUILD_DIR
          $artifactsRoot = Join-Path $workspace $Env:LICENX_ARTIFACT_ROOT
          $publishDir = Join-Path $artifactsRoot 'publish'
          $cliDir = Join-Path $artifactsRoot 'admin-cli'
          $sdkDir = Join-Path $artifactsRoot 'sdk'
          $sdkLibDir = Join-Path $sdkDir 'lib'
          $sdkIncludeDir = Join-Path $sdkDir 'include'

          $directories = @($artifactsRoot, $publishDir, $cliDir, $sdkDir, $sdkLibDir, $sdkIncludeDir)
          foreach ($dir in $directories) {
            if (-not (Test-Path $dir)) {
              New-Item -ItemType Directory -Path $dir | Out-Null
            }
            else {
              Get-ChildItem -Path $dir -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            }
          }

          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $outputDir = if ($multiConfig) { Join-Path $buildDir $Env:LICENX_BUILD_CONFIG } else { $buildDir }

          $cliCandidates = @(
            (Join-Path -Path $outputDir -ChildPath 'licenx_admin_cli.exe')
            (Join-Path -Path $outputDir -ChildPath 'licenx_admin_cli')
            (Join-Path -Path $buildDir -ChildPath 'licenx_admin_cli.exe')
            (Join-Path -Path $buildDir -ChildPath 'licenx_admin_cli')
          )

          $cliPath = $null
          foreach ($candidate in $cliCandidates) {
            if (Test-Path $candidate) {
              $cliPath = $candidate
              break
            }
          }

          if (-not $cliPath) {
            throw "Expected CLI artifact not found. Checked: $($cliCandidates -join ', ')"
          }

          $versionSegment = $Env:LICENX_VERSION_FILESAFE
          $useVersionedNames = -not [string]::IsNullOrWhiteSpace($versionSegment)

          $cliSourceName = Split-Path -Path $cliPath -Leaf
          $cliBase = [System.IO.Path]::GetFileNameWithoutExtension($cliSourceName)
          $cliExt = [System.IO.Path]::GetExtension($cliSourceName)
          if ($useVersionedNames) {
            $cliDestName = if ([string]::IsNullOrEmpty($cliExt)) { "$cliBase-$versionSegment" } else { "$cliBase-$versionSegment$cliExt" }
          }
          else {
            $cliDestName = $cliSourceName
          }
          $cliDestPath = Join-Path $cliDir $cliDestName
          Copy-Item $cliPath $cliDestPath -Force

          $libraryPatterns = @('licenx*.lib','licenx*.dll','licenx*.exp','licenx*.pdb','liblicenx*.a','liblicenx*.so','liblicenx*.dylib')
          $libraries = @()
          foreach ($pattern in $libraryPatterns) {
            $libraries += Get-ChildItem -Path $outputDir -Recurse -File -Filter $pattern -ErrorAction SilentlyContinue
          }
          $libraries = $libraries | Sort-Object -Property FullName -Unique
          if ($libraries.Count -eq 0) {
            throw "No LicenX library artifacts matching expected patterns were found in $outputDir"
          }
          foreach ($lib in $libraries) {
            $destName = $lib.Name
            if ($useVersionedNames) {
              $base = [System.IO.Path]::GetFileNameWithoutExtension($lib.Name)
              $ext = $lib.Extension
              $destName = if ([string]::IsNullOrEmpty($ext)) { "$base-$versionSegment" } else { "$base-$versionSegment$ext" }
            }
            Copy-Item $lib.FullName (Join-Path $sdkLibDir $destName) -Force
          }

          $includeSource = Join-Path $workspace (Join-Path $Env:LICENX_SOURCE_DIR 'include')
          if (-not (Test-Path $includeSource)) {
            throw "Header directory not found at $includeSource"
          }
          Copy-Item (Join-Path $includeSource '*') $sdkIncludeDir -Recurse -Force

          $readmeSource = Join-Path $workspace (Join-Path $Env:LICENX_SOURCE_DIR 'README.md')
          if (Test-Path $readmeSource) {
            Copy-Item $readmeSource $sdkDir -Force
          }

          $platform = $Env:ARTIFACT_PLATFORM_SUFFIX
          $artifactSuffix = if ($useVersionedNames) { "$platform-$versionSegment" } else { $platform }
          $cliZip = Join-Path $publishDir "licenx-admin-cli-$artifactSuffix.zip"
          $sdkZip = Join-Path $publishDir "licenx-sdk-$artifactSuffix.zip"

          if (Test-Path $cliZip) { Remove-Item $cliZip -Force }
          if (Test-Path $sdkZip) { Remove-Item $sdkZip -Force }

          Compress-Archive -Path (Join-Path $cliDir '*') -DestinationPath $cliZip -Force
          Compress-Archive -Path (Join-Path $sdkDir '*') -DestinationPath $sdkZip -Force

          "publish-dir=$publishDir" | Out-File -FilePath $Env:GITHUB_OUTPUT -Encoding utf8 -Append

      - name: Azure login (artifact staging)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Stage packaged artifacts in Azure Storage
        shell: pwsh
        env:
          PUBLISH_DIR: ${{ steps.package.outputs.publish-dir }}
        run: |
          $ErrorActionPreference = 'Stop'
          $publishDir = $Env:PUBLISH_DIR
          if ([string]::IsNullOrWhiteSpace($publishDir) -or -not (Test-Path $publishDir)) {
            throw "Publish directory $publishDir not found."
          }

          $container = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_CONTAINER)) {
            'licenx-workflow-staging'
          }
          else {
            $Env:WORKFLOW_ARTIFACT_CONTAINER.Trim()
          }

          $prefixRoot = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_PREFIX)) {
            "workflow-runs/$($Env:GITHUB_RUN_ID)"
          }
          else {
            $Env:WORKFLOW_ARTIFACT_PREFIX.Trim().TrimEnd('/')
          }

          $platform = if ([string]::IsNullOrWhiteSpace($Env:ARTIFACT_PLATFORM_SUFFIX)) {
            'windows'
          }
          else {
            $Env:ARTIFACT_PLATFORM_SUFFIX.Trim()
          }

          $destinationPath = "$prefixRoot/$platform"

          az storage container create `
            --name $container `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --only-show-errors | Out-Null

          az storage blob upload-batch `
            --destination $container `
            --source $publishDir `
            --destination-path $destinationPath `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --pattern '*' `
            --overwrite `
            --no-progress | Out-Null

          Write-Host "Staged $publishDir to Azure storage path $container/$destinationPath"

  publish-and-docker:
    name: Publish artifacts & Docker image
    needs:
      - build-linux
      - build-macos
      - build-windows
    runs-on: ubuntu-latest
    env:
      CMAKE_GENERATOR: Ninja
      CMAKE_BUILD_TYPE: Release
      CMAKE_MULTICONFIG: "false"
      ARTIFACT_PLATFORM_SUFFIX: linux
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: false

      - name: Prepare LicenX workspace
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $moduleDir = [System.IO.Path]::Combine($Env:GITHUB_WORKSPACE, '.git/modules', $Env:LICENX_SUBMODULE_PATH)
          if (Test-Path $moduleDir) {
            Remove-Item $moduleDir -Recurse -Force
          }
          if (Test-Path $Env:LICENX_SUBMODULE_PATH) {
            Remove-Item $Env:LICENX_SUBMODULE_PATH -Recurse -Force
          }

      - name: Checkout LicenX source
        uses: actions/checkout@v4
        with:
          repository: ergosumx/licenx
          ref: ${{ github.event.inputs.licenx-tag }}
          path: ${{ env.LICENX_SUBMODULE_PATH }}
          fetch-depth: 0
          submodules: recursive
          token: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}

      - name: Prepare LicenX version metadata
        shell: pwsh
        env:
          INPUT_TAG: ${{ env.LICENX_TAG }}
          BUILD_RUN_ID: ${{ github.run_id }}
        run: |
          $ErrorActionPreference = 'Stop'
          $tagInput = $Env:INPUT_TAG
          if ([string]::IsNullOrWhiteSpace($tagInput)) {
            throw 'LICENX_TAG must be provided for this workflow.'
          }

          $candidate = $tagInput.Trim()

          $fileSafe = $candidate -replace '[^0-9A-Za-z.+-]', '-'
          if ([string]::IsNullOrWhiteSpace($fileSafe)) {
            $fileSafe = '0.0.0'
          }

          $dockerSafe = $fileSafe.ToLowerInvariant()

          $numericSource = $fileSafe
          if ($numericSource.StartsWith('v', [System.StringComparison]::OrdinalIgnoreCase)) {
            $numericSource = $numericSource.Substring(1)
          }

          $numericCore = $numericSource.Split('-', 2)[0]
          if ([string]::IsNullOrWhiteSpace($numericCore)) {
            $numericCore = '0.0.0'
          }

          $segments = $numericCore.Split('.', [System.StringSplitOptions]::RemoveEmptyEntries)
          if ($segments.Count -eq 0) {
            $segments = @('0','0','0')
          }

          $intSegments = @()
          foreach ($segment in $segments) {
            if ($segment -match '^[0-9]+$') {
              $intSegments += [int]$segment
            }
            else {
              $intSegments += 0
            }
          }
          while ($intSegments.Count -lt 4) {
            $intSegments += 0
          }

          $major = $intSegments[0]
          $minor = $intSegments[1]
          $patch = $intSegments[2]
          $build = $intSegments[3]

          $runId = $Env:BUILD_RUN_ID
          if (-not [string]::IsNullOrWhiteSpace($runId)) {
            $runId = $runId.Trim()
            if ($runId -match '^[0-9]+$') {
              $build = $runId
            }
            else {
              Write-Host "::warning::Workflow run id '$runId' is not numeric; continuing with parsed build segment $build."
            }
          }

          $semver = "{0}.{1}.{2}" -f $major, $minor, $patch
          $productVersion = "{0}.{1}.{2}.{3}" -f $major, $minor, $patch, $build
          $fileVersion = "{0},{1},{2},{3}" -f $major, $minor, $patch, $build
          $hasTag = 'true'
          $dockerWithBuild = $dockerSafe
          if (-not [string]::IsNullOrWhiteSpace($dockerWithBuild) -and -not [string]::IsNullOrWhiteSpace($build)) {
            $dockerWithBuild = "$dockerWithBuild.$build"
          }

          $versionString = if ([string]::IsNullOrWhiteSpace($dockerWithBuild)) { $fileSafe } else { $dockerWithBuild }

          @(
            "LICENX_VERSION_INPUT=$candidate"
            "LICENX_VERSION_FILESAFE=$fileSafe"
            "LICENX_VERSION_STRING=$versionString"
            "LICENX_VERSION_SEMVER=$semver"
            "LICENX_VERSION_MAJOR=$major"
            "LICENX_VERSION_MINOR=$minor"
            "LICENX_VERSION_PATCH=$patch"
            "LICENX_VERSION_BUILD=$build"
            "LICENX_VERSION_PRODUCT_VERSION=$productVersion"
            "LICENX_VERSION_FILE_VERSION=$fileVersion"
            "LICENX_VERSION_HAS_TAG=$hasTag"
            "LICENX_VERSION_DOCKER_TAG=$dockerSafe"
            "LICENX_VERSION_DOCKER_TAG_WITH_BUILD=$dockerWithBuild"
          ) | Out-File -FilePath $Env:GITHUB_ENV -Encoding utf8 -Append

          Write-Host "Resolved LicenX version: $fileSafe (semver: $semver)"

      - name: Install build dependencies
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y \
            ninja-build \
            pkg-config \
            autoconf \
            automake \
            libtool \
            m4 \
            libcurl4-openssl-dev \
            libsodium-dev \
            libssl-dev \
            zlib1g-dev

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 8.0.x

      - name: Configure LicenX build (container stage)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $cmakeArgs = @(
            '-S', $Env:LICENX_SOURCE_DIR,
            '-B', $Env:LICENX_BUILD_DIR,
            '-G', $Env:CMAKE_GENERATOR,
            "-DLICENX_ENVIRONMENT=$Env:LICENX_ENVIRONMENT_INPUT",
            '-DLICENX_BUILD_TESTS=OFF',
            '-DLICENX_USE_VENDORED_DEPS=ON',
            '-DLICENX_BUILD_GATEWAY=OFF'
          )
          if ($Env:CMAKE_MULTICONFIG -ne 'true') {
            $cmakeArgs += "-DCMAKE_BUILD_TYPE=$Env:CMAKE_BUILD_TYPE"
          }
          if ($Env:CMAKE_GENERATOR_PLATFORM) {
            $cmakeArgs += '-A'
            $cmakeArgs += $Env:CMAKE_GENERATOR_PLATFORM
          }
          if ($Env:CMAKE_TOOLCHAIN_FILE) {
            $cmakeArgs += "-DCMAKE_TOOLCHAIN_FILE=$Env:CMAKE_TOOLCHAIN_FILE"
          }
          if ($Env:CMAKE_PREFIX_PATH) {
            $cmakeArgs += "-DCMAKE_PREFIX_PATH=$Env:CMAKE_PREFIX_PATH"
          }
          if ($Env:LICENX_VERSION_STRING) {
            $cmakeArgs += "-DLICENX_VERSION_STRING=$Env:LICENX_VERSION_STRING"
          }
          cmake @cmakeArgs

      - name: Build LicenX artifacts (container stage)
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $multiConfig = $Env:CMAKE_MULTICONFIG -eq 'true'
          $args = @('--build', $Env:LICENX_BUILD_DIR)
          if ($multiConfig) { $args += @('--config', $Env:LICENX_BUILD_CONFIG) }
          cmake @args

      - name: Azure login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Download staged artifacts from Azure Storage
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $container = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_CONTAINER)) {
            'licenx-workflow-staging'
          }
          else {
            $Env:WORKFLOW_ARTIFACT_CONTAINER.Trim()
          }

          $prefixRoot = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_PREFIX)) {
            "workflow-runs/$($Env:GITHUB_RUN_ID)"
          }
          else {
            $Env:WORKFLOW_ARTIFACT_PREFIX.Trim().TrimEnd('/')
          }

          if ([string]::IsNullOrWhiteSpace($container)) {
            throw 'WORKFLOW_ARTIFACT_CONTAINER must be set for Azure staging downloads.'
          }

          $destRoot = Join-Path $Env:GITHUB_WORKSPACE 'collected'
          $platforms = @('windows','linux','macos')

          foreach ($platform in $platforms) {
            $destinationDir = Join-Path $destRoot $platform
            $publishDir = Join-Path $destinationDir 'publish'
            if (-not (Test-Path $publishDir)) {
              New-Item -ItemType Directory -Path $publishDir -Force | Out-Null
            }
            else {
              Get-ChildItem -Path $publishDir -Force -ErrorAction SilentlyContinue | Remove-Item -Force -Recurse -ErrorAction SilentlyContinue
            }

            $sourcePath = "$prefixRoot/$platform"

            Write-Host "Downloading staged artifacts from $container/$sourcePath to $publishDir"

            $tempDir = Join-Path $Env:RUNNER_TEMP ([System.Guid]::NewGuid().ToString())
            New-Item -ItemType Directory -Path $tempDir -Force | Out-Null

            $pattern = "$sourcePath/*"

            az storage blob download-batch `
              --source $container `
              --destination $tempDir `
              --account-name $Env:AZURE_STORAGE_ACCOUNT `
              --auth-mode login `
              --pattern $pattern `
              --no-progress | Out-Null

            $downloadRoot = Join-Path $tempDir $sourcePath
            if (-not (Test-Path $downloadRoot)) {
              Write-Host "::warning::No staged artifacts found at $container/$sourcePath"
              continue
            }

            Get-ChildItem -Path $downloadRoot -Force -ErrorAction SilentlyContinue | ForEach-Object {
              $target = Join-Path $publishDir $_.Name
              if ($_.PSIsContainer) {
                Copy-Item -Path $_.FullName -Destination $target -Recurse -Force
              }
              else {
                Copy-Item -Path $_.FullName -Destination $publishDir -Force
              }
            }

            Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
          }

      - name: Publish packages to Azure Files
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $source = Join-Path $Env:GITHUB_WORKSPACE 'collected'
          if (-not (Test-Path $source)) {
            throw "Collected artifacts directory $source not found."
          }

          $containerName = 'build-artifacts'

          $targets = @(
            @{ Folder = 'windows'; Destination = "$($Env:AZURE_STORAGE_PATH)/windows-x64" },
            @{ Folder = 'linux'; Destination = "$($Env:AZURE_STORAGE_PATH)/linux-x64" },
            @{ Folder = 'macos'; Destination = "$($Env:AZURE_STORAGE_PATH)/macos-universal" }
          )

          az storage container create `
            --name $containerName `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login `
            --only-show-errors | Out-Null

          foreach ($target in $targets) {
            $platformSource = Join-Path $source $target.Folder
            if (-not (Test-Path $platformSource)) {
              Write-Host "::warning::Platform artifacts not found at $platformSource. Skipping upload to container $containerName path $($target.Destination)."
              continue
            }

            az storage blob upload-batch `
              --source $platformSource `
              --account-name $Env:AZURE_STORAGE_ACCOUNT `
              --destination $containerName `
              --destination-path $target.Destination `
              --overwrite `
              --no-progress `
              --auth-mode login
          }

      - name: Build and push LicenX server image
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'
          $dockerfileInput = "${{ github.event.inputs.dockerfile-relative-path }}"
          if ([string]::IsNullOrWhiteSpace($dockerfileInput)) {
            $dockerfileInput = 'docker/Dockerfile'
            Write-Host "::notice::dockerfile-relative-path input not provided; defaulting to $dockerfileInput"
          }

          $dockerfileInput = $dockerfileInput.Trim()

          # Construct path relative to the licenx submodule
          $dockerfile = Join-Path $Env:GITHUB_WORKSPACE $Env:LICENX_SUBMODULE_PATH $dockerfileInput

          if (-not (Test-Path $dockerfile)) {
            Write-Host "::warning::Dockerfile not found at $dockerfile. Checked: $Env:LICENX_SUBMODULE_PATH/$dockerfileInput"
            return
          }

          $acrLoginServer = $Env:ACR_LOGIN_SERVER
          $acrImageName = $Env:ACR_IMAGE_NAME

          if ([string]::IsNullOrWhiteSpace($acrLoginServer)) {
            throw "ACR_LOGIN_SERVER environment variable is not set."
          }

          $acrLoginServer = $acrLoginServer.Trim()

          if ([string]::IsNullOrWhiteSpace($acrImageName)) {
            $acrImageName = 'licenxsrv'
            Write-Host "::warning::ACR_IMAGE_NAME not set; defaulting to '$acrImageName'."
          }

          $acrImageName = $acrImageName.Trim()

          Write-Host "Using ACR login server: $acrLoginServer"
          Write-Host "Using ACR image name: $acrImageName"

          $context = Join-Path $Env:GITHUB_WORKSPACE $Env:LICENX_SUBMODULE_PATH
          if (-not (Test-Path $context)) {
            throw "Docker build context $context not found."
          }

          $context = (Resolve-Path $context).Path
          Write-Host "Using docker build context: $context"

          az acr login --name $Env:ACR_REGISTRY

          $dockerTagBase = $Env:LICENX_VERSION_DOCKER_TAG
          $dockerTagWithBuild = $Env:LICENX_VERSION_DOCKER_TAG_WITH_BUILD
          $imageTag = $Env:LICENX_VERSION_FILESAFE

          if ([string]::IsNullOrWhiteSpace($dockerTagBase)) {
            $candidate = $Env:LICENX_TAG
            if (-not [string]::IsNullOrWhiteSpace($candidate)) {
              $candidate = $candidate.Trim()
              $candidate = $candidate -replace '[^0-9A-Za-z.+-]', '-'
              if (-not [string]::IsNullOrWhiteSpace($candidate)) {
                $dockerTagBase = $candidate.ToLowerInvariant()
                Write-Host "Derived base docker tag from LICENX_TAG input: $dockerTagBase"
              }
            }
          }

          if ([string]::IsNullOrWhiteSpace($dockerTagWithBuild) -and -not [string]::IsNullOrWhiteSpace($dockerTagBase)) {
            $buildSegment = $Env:LICENX_VERSION_BUILD
            if (-not [string]::IsNullOrWhiteSpace($buildSegment)) {
              $buildSegment = $buildSegment.Trim()
              if ($buildSegment -match '^[0-9]+$') {
                $dockerTagWithBuild = "$dockerTagBase.$buildSegment"
              }
            }
          }

          Write-Host "Docker tag (base): $dockerTagBase"
          Write-Host "Docker tag (with build): $dockerTagWithBuild"
          Write-Host "Docker tag (filesafe fallback): $imageTag"

          $primaryTagValue = $null
          foreach ($candidate in @($dockerTagWithBuild, $dockerTagBase, $imageTag)) {
            if (-not [string]::IsNullOrWhiteSpace($candidate)) {
              $primaryTagValue = $candidate
              break
            }
          }
          if ([string]::IsNullOrWhiteSpace($primaryTagValue)) {
            $primaryTagValue = 'latest'
          }

          $tags = @()
          foreach ($candidateTag in @($primaryTagValue, $dockerTagWithBuild, $dockerTagBase, $imageTag, 'latest')) {
            if (-not [string]::IsNullOrWhiteSpace($candidateTag) -and ($tags -notcontains $candidateTag)) {
              $tags += $candidateTag
            }
          }

          $primaryTag = "$acrLoginServer/${acrImageName}:$primaryTagValue"
          Write-Host "Building image with primary tag: $primaryTag"
          Write-Host "All docker tags to publish: $($tags -join ', ')"

          $buildArgs = @('--file', $dockerfile, '--tag', $primaryTag)
          if (-not [string]::IsNullOrWhiteSpace($Env:LICENX_VERSION_STRING)) {
            $buildArgs += '--build-arg'
            $buildArgs += "LICENX_VERSION_STRING=$($Env:LICENX_VERSION_STRING)"
          }

          docker build @buildArgs $context

          for ($i = 1; $i -lt $tags.Count; $i++) {
            $targetTag = "$acrLoginServer/${acrImageName}:$($tags[$i])"
            Write-Host "Tagging image as: $targetTag"
            docker tag $primaryTag $targetTag
          }

          foreach ($tag in $tags) {
            $pushTag = "$acrLoginServer/${acrImageName}:$tag"
            Write-Host "Pushing image tag: $pushTag"
            docker push $pushTag
          }

      - name: Create release in LicenX submodule
        if: ${{ env.LICENX_TAG != '' }}
        shell: bash
        env:
          REPO: ergosumx/licenx
          TOKEN: ${{ secrets.ERGOX_SUBMODULE_TOKEN }}
          SUBMODULE_PATH: ${{ env.LICENX_SUBMODULE_PATH }}
          TAG: ${{ github.event.inputs.licenx-tag }}
          ASSET_DIRS: |
            ${{ github.workspace }}/collected/windows/publish
            ${{ github.workspace }}/collected/linux/publish
            ${{ github.workspace }}/collected/macos/publish
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import json
          import os
          import subprocess
          import sys
          import urllib.error
          import urllib.parse
          import urllib.request

          token = os.environ.get("TOKEN")
          tag = os.environ.get("TAG")
          if not token:
              print("::error::ERGOX_SUBMODULE_TOKEN secret is not available")
              sys.exit(1)
          if not tag:
              print("::warning::Release tag input is empty; skipping release creation")
              sys.exit(0)

          repo = os.environ["REPO"]
          workspace = os.environ["GITHUB_WORKSPACE"]
          submodule_rel = os.environ.get("SUBMODULE_PATH", "")
          submodule_path = os.path.join(workspace, submodule_rel)
          asset_dirs = [line.strip() for line in os.environ.get("ASSET_DIRS", "").splitlines() if line.strip()]

          if not os.path.isdir(submodule_path):
              print(f"::error::Submodule path {submodule_path} not found")
              sys.exit(1)

          sha = subprocess.check_output(["git", "rev-parse", "HEAD"], cwd=submodule_path, text=True).strip()
          print(f"Preparing release {tag} for commit {sha}")

          def api_request(method: str, url: str, data: bytes | None = None, headers: dict | None = None):
              headers = headers.copy() if headers else {}
              headers.setdefault("Authorization", f"token {token}")
              headers.setdefault("Accept", "application/vnd.github+json")
              if data is not None and "Content-Type" not in headers:
                  headers["Content-Type"] = "application/json"
              request = urllib.request.Request(url, data=data, headers=headers, method=method)
              try:
                  with urllib.request.urlopen(request) as response:
                      return response.getcode(), response.read()
              except urllib.error.HTTPError as exc:
                  return exc.code, exc.read()

          payload = json.dumps({
              "tag_name": tag,
              "name": tag,
              "body": f"Automated release for {tag}",
              "target_commitish": sha,
          }).encode("utf-8")

          create_url = f"https://api.github.com/repos/{repo}/releases"
          status, body = api_request("POST", create_url, data=payload)

          if status in (200, 201):
              release = json.loads(body)
              print(f"Created new release {tag} (HTTP {status})")
          elif status == 422:
              lookup_url = f"https://api.github.com/repos/{repo}/releases/tags/{urllib.parse.quote(tag)}"
              status, body = api_request("GET", lookup_url)
              if status != 200:
                  print(f"::error::Failed to retrieve existing release for {tag} (HTTP {status})\n{body.decode('utf-8', 'ignore')}")
                  sys.exit(1)
              release = json.loads(body)
              print(f"Reusing existing release {tag}")
          else:
              print(f"::error::Failed to create release (HTTP {status})\n{body.decode('utf-8', 'ignore')}")
              sys.exit(1)

          upload_url = release.get("upload_url", "").split("{")[0]
          release_id = release.get("id")
          if not upload_url or not release_id:
              print("::error::Release response missing upload URL or ID")
              sys.exit(1)

          existing_assets = []
          assets_url = f"https://api.github.com/repos/{repo}/releases/{release_id}/assets"
          status, assets_body = api_request("GET", assets_url)
          if status == 200:
              existing_assets = json.loads(assets_body)
          else:
              print(f"::warning::Failed to list existing assets (HTTP {status})")

          selected_files: list[tuple[str, str]] = []
          for directory in asset_dirs:
              if not os.path.isdir(directory):
                  print(f"::warning::Asset directory {directory} not found; skipping")
                  continue
              for entry in sorted(os.listdir(directory)):
                  path = os.path.join(directory, entry)
                  if os.path.isfile(path) and entry.lower().endswith(".zip"):
                      selected_files.append((entry, path))

          if not selected_files:
              print("::warning::No release assets discovered; release will not include binaries")
          else:
              for asset in existing_assets:
                  if any(asset.get("name") == name for name, _ in selected_files):
                      delete_status, _ = api_request("DELETE", asset.get("url"))
                      if delete_status not in (200, 204):
                          print(f"::warning::Failed to delete existing asset {asset.get('name')} (HTTP {delete_status})")

              for name, path in selected_files:
                  with open(path, "rb") as handle:
                      data = handle.read()
                  target = f"{upload_url}?name={urllib.parse.quote(name)}"
                  headers = {"Content-Type": "application/zip"}
                  upload_status, upload_body = api_request("POST", target, data=data, headers=headers)
                  if upload_status not in (200, 201):
                      print(f"::error::Failed to upload asset {name} (HTTP {upload_status})\n{upload_body.decode('utf-8', 'ignore')}")
                      sys.exit(1)
                  print(f"Uploaded asset {name} ({len(data)} bytes)")

          html_url = release.get("html_url")
          if html_url:
              print(f"Release available at {html_url}")
          PY

      - name: Cleanup Azure staging artifacts
        if: ${{ always() }}
        shell: pwsh
        run: |
          $ErrorActionPreference = 'Stop'

          $container = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_CONTAINER)) {
            'licenx-workflow-staging'
          }
          else {
            $Env:WORKFLOW_ARTIFACT_CONTAINER.Trim()
          }

          $prefixRoot = if ([string]::IsNullOrWhiteSpace($Env:WORKFLOW_ARTIFACT_PREFIX)) {
            "workflow-runs/$($Env:GITHUB_RUN_ID)"
          }
          else {
            $Env:WORKFLOW_ARTIFACT_PREFIX.Trim().TrimEnd('/')
          }

          if ([string]::IsNullOrWhiteSpace($container)) {
            Write-Host 'No staging container configured; skipping cleanup.'
            return
          }

          Write-Host "Cleaning up staged artifacts from $container/$prefixRoot"

          az storage blob delete-batch `
            --source $container `
            --pattern "$prefixRoot/*" `
            --account-name $Env:AZURE_STORAGE_ACCOUNT `
            --auth-mode login | Out-Null
